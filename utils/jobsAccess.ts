import { getSupabase } from '@/lib/supabase';
import type {
  Job,
  JobWithRelations,
  JobFormData,
  JobFilters,
  JobStatus,
  JobOperation,
  JobAttachment,
} from '@/types/job';
import {
  deleteFileFromStorage,
  getSignedUrl,
} from './storageHelpers';

/**
 * Sanitize search string for use in LIKE/ILIKE queries
 */
function sanitizeSearchString(search: string): string {
  return search
    .replace(/\\/g, '\\\\')
    .replace(/%/g, '\\%')
    .replace(/_/g, '\\_')
    .substring(0, 100);
}

// ============== CRUD Operations ==============

/**
 * Get all jobs for a company (batch fetch for AG Grid).
 * Fetches in batches of 1000 to bypass Supabase's default row limit.
 */
export async function getAllJobs(
  companyId: string,
  filters: JobFilters = {},
  sortField: string = 'created_at',
  sortDirection: 'asc' | 'desc' = 'desc'
): Promise<JobWithRelations[]> {
  const supabase = getSupabase();
  const BATCH_SIZE = 1000;
  let allData: JobWithRelations[] = [];
  let offset = 0;
  let hasMore = true;

  while (hasMore) {
    let query = supabase
      .from('jobs')
      .select(
        `
        *,
        customers!left(id, name, customer_code),
        parts!left(id, part_number, description),
        quotes!jobs_quote_id_fkey(id, quote_number, total_price)
      `
      )
      .eq('company_id', companyId)
      .order(sortField, { ascending: sortDirection === 'asc' })
      .range(offset, offset + BATCH_SIZE - 1);

    // Apply filters
    if (filters.status && filters.status !== 'all') {
      if (filters.status === 'active') {
        // Active = not shipped, not cancelled
        query = query.not('status', 'in', '("shipped","cancelled")');
      } else {
        query = query.eq('status', filters.status);
      }
    }

    if (filters.customerId) {
      query = query.eq('customer_id', filters.customerId);
    }

    if (filters.search?.trim()) {
      const sanitized = sanitizeSearchString(filters.search.trim());
      query = query.or(
        `job_number.ilike.%${sanitized}%,description.ilike.%${sanitized}%`
      );
    }

    const { data, error } = await query;

    if (error) {
      console.error('Error fetching jobs batch:', error);
      throw error;
    }

    allData = [...allData, ...((data || []) as JobWithRelations[])];
    hasMore = (data?.length || 0) === BATCH_SIZE;
    offset += BATCH_SIZE;
  }

  return allData;
}

/**
 * Get a single job with all relations
 */
export async function getJobWithRelations(
  jobId: string,
  companyId: string
): Promise<JobWithRelations | null> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('jobs')
    .select(
      `
      *,
      customers!left(id, name, customer_code),
      parts!left(id, part_number, description),
      quotes!jobs_quote_id_fkey(id, quote_number, total_price),
      routings!left(id, name),
      job_operations(
        *,
        operation_types!left(id, name, labor_rate)
      ),
      job_attachments(*)
    `
    )
    .eq('id', jobId)
    .eq('company_id', companyId)
    .single();

  if (error && error.code !== 'PGRST116') {
    console.error('Error fetching job with relations:', error);
    throw error;
  }

  // Sort operations by sequence
  if (data?.job_operations) {
    data.job_operations.sort((a: JobOperation, b: JobOperation) => a.sequence - b.sequence);
  }

  return data as JobWithRelations | null;
}

/**
 * Create a new job directly (not from quote)
 */
export async function createJob(
  companyId: string,
  formData: JobFormData
): Promise<Job> {
  const supabase = getSupabase();

  // Input validation
  const quantity = parseInt(formData.quantity_ordered, 10);
  if (isNaN(quantity) || quantity < 1 || quantity > 1000000) {
    throw new Error('Quantity must be between 1 and 1,000,000');
  }

  if (!formData.customer_id) {
    throw new Error('Customer is required');
  }

  // Get current user
  const { data: { user } } = await supabase.auth.getUser();

  const { data, error } = await supabase
    .from('jobs')
    .insert({
      company_id: companyId,
      customer_id: formData.customer_id,
      part_id: formData.part_id || null,
      routing_id: formData.routing_id || null,
      description: formData.description.trim() || null,
      quantity_ordered: quantity,
      quantity_completed: 0,
      quantity_scrapped: 0,
      due_date: formData.due_date || null,
      priority: formData.priority || 'normal',
      status: 'pending',
      created_by: user?.id || null,
      // job_number is auto-generated by database trigger
    })
    .select()
    .single();

  if (error) {
    console.error('Error creating job:', error);
    throw error;
  }

  // If there's a routing, copy operations to job
  if (formData.routing_id) {
    try {
      await createJobOperationsFromRouting(data.id, formData.routing_id);
    } catch (opsError) {
      console.error('Failed to copy operations from routing:', opsError);
      // Don't fail the job creation, just log the error
    }
  }

  return data;
}

/**
 * Update an existing job
 */
export async function updateJob(jobId: string, formData: JobFormData): Promise<Job> {
  const supabase = getSupabase();

  // First check if job can be edited (pending or on_hold)
  const { data: existing, error: checkError } = await supabase
    .from('jobs')
    .select('status')
    .eq('id', jobId)
    .single();

  if (checkError) {
    console.error('Error checking job status:', checkError);
    throw checkError;
  }

  const editableStatuses: JobStatus[] = ['pending', 'on_hold'];
  if (!editableStatuses.includes(existing.status as JobStatus)) {
    throw new Error('Only pending or on hold jobs can be edited');
  }

  // Input validation
  const quantity = parseInt(formData.quantity_ordered, 10);
  if (isNaN(quantity) || quantity < 1 || quantity > 1000000) {
    throw new Error('Quantity must be between 1 and 1,000,000');
  }

  const { data, error } = await supabase
    .from('jobs')
    .update({
      customer_id: formData.customer_id,
      part_id: formData.part_id || null,
      routing_id: formData.routing_id || null,
      description: formData.description.trim() || null,
      quantity_ordered: quantity,
      due_date: formData.due_date || null,
      priority: formData.priority || 'normal',
      updated_at: new Date().toISOString(),
    })
    .eq('id', jobId)
    .select()
    .single();

  if (error) {
    console.error('Error updating job:', error);
    throw error;
  }

  return data;
}

/**
 * Delete a job and its attachments from storage
 */
export async function deleteJob(jobId: string, companyId: string): Promise<void> {
  const supabase = getSupabase();

  // 1. Get job's attachments for storage cleanup
  const { data: attachments } = await supabase
    .from('job_attachments')
    .select('file_path')
    .eq('job_id', jobId)
    .eq('company_id', companyId);

  // 2. Delete storage files (best effort)
  if (attachments && attachments.length > 0) {
    for (const attachment of attachments) {
      try {
        await deleteFileFromStorage(attachment.file_path);
      } catch (storageError) {
        console.warn('Failed to delete storage file:', attachment.file_path, storageError);
      }
    }
  }

  // 3. Delete the job record (cascade will delete operations and attachments from DB)
  const { error } = await supabase
    .from('jobs')
    .delete()
    .eq('id', jobId)
    .eq('company_id', companyId);

  if (error) {
    console.error('Error deleting job:', error);
    throw error;
  }
}

/**
 * Bulk delete jobs and their attachments
 */
export async function bulkDeleteJobs(jobIds: string[], companyId: string): Promise<void> {
  if (jobIds.length === 0) return;

  const validIds = jobIds.filter((id) => id && typeof id === 'string');
  if (validIds.length === 0) return;

  const supabase = getSupabase();

  // 1. Get all attachments for these jobs
  const { data: attachments } = await supabase
    .from('job_attachments')
    .select('file_path')
    .in('job_id', validIds)
    .eq('company_id', companyId);

  // 2. Delete storage files (best effort)
  if (attachments && attachments.length > 0) {
    for (const attachment of attachments) {
      try {
        await deleteFileFromStorage(attachment.file_path);
      } catch (storageError) {
        console.warn('Failed to delete storage file:', attachment.file_path, storageError);
      }
    }
  }

  // 3. Delete jobs in batches
  const BATCH_SIZE = 100;
  for (let i = 0; i < validIds.length; i += BATCH_SIZE) {
    const batch = validIds.slice(i, i + BATCH_SIZE);

    const { error } = await supabase
      .from('jobs')
      .delete()
      .in('id', batch)
      .eq('company_id', companyId);

    if (error) {
      console.error('Error bulk deleting jobs:', error);
      throw new Error(error.message || 'Failed to delete jobs');
    }
  }
}

// ============== Status Transitions ==============

/**
 * Helper to update job status with validation
 */
async function updateJobStatus(
  jobId: string,
  expectedCurrentStatus: JobStatus | JobStatus[],
  newStatus: JobStatus,
  additionalUpdates: Record<string, unknown> = {}
): Promise<Job> {
  const supabase = getSupabase();

  const { data: existing, error: checkError } = await supabase
    .from('jobs')
    .select('status')
    .eq('id', jobId)
    .single();

  if (checkError) {
    console.error('Error checking job status:', checkError);
    throw checkError;
  }

  const allowedStatuses = Array.isArray(expectedCurrentStatus)
    ? expectedCurrentStatus
    : [expectedCurrentStatus];

  if (!allowedStatuses.includes(existing.status as JobStatus)) {
    throw new Error(`Cannot change status from ${existing.status} to ${newStatus}`);
  }

  const { data, error } = await supabase
    .from('jobs')
    .update({
      status: newStatus,
      ...additionalUpdates,
      updated_at: new Date().toISOString(),
    })
    .eq('id', jobId)
    .select()
    .single();

  if (error) {
    console.error('Error updating job status:', error);
    throw error;
  }

  return data;
}

/**
 * Start a job (PENDING → IN_PROGRESS)
 */
export async function startJob(jobId: string): Promise<Job> {
  return updateJobStatus(jobId, 'pending', 'in_progress', {
    started_at: new Date().toISOString(),
  });
}

/**
 * Complete a job (IN_PROGRESS → COMPLETED)
 */
export async function completeJob(jobId: string): Promise<Job> {
  return updateJobStatus(jobId, 'in_progress', 'completed', {
    completed_at: new Date().toISOString(),
  });
}

/**
 * Ship a job (COMPLETED → SHIPPED)
 */
export async function shipJob(jobId: string): Promise<Job> {
  return updateJobStatus(jobId, 'completed', 'shipped', {
    shipped_at: new Date().toISOString(),
  });
}

/**
 * Cancel a job (any status → CANCELLED)
 */
export async function cancelJob(jobId: string): Promise<Job> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('jobs')
    .update({
      status: 'cancelled',
      updated_at: new Date().toISOString(),
    })
    .eq('id', jobId)
    .select()
    .single();

  if (error) {
    console.error('Error cancelling job:', error);
    throw error;
  }

  return data;
}

/**
 * Put a job on hold (IN_PROGRESS → ON_HOLD)
 */
export async function putJobOnHold(jobId: string): Promise<Job> {
  return updateJobStatus(jobId, 'in_progress', 'on_hold');
}

/**
 * Resume a job from hold (ON_HOLD → IN_PROGRESS)
 */
export async function resumeJob(jobId: string): Promise<Job> {
  return updateJobStatus(jobId, 'on_hold', 'in_progress');
}

// ============== Operations ==============

/**
 * Get operations for a job
 */
export async function getJobOperations(jobId: string): Promise<JobOperation[]> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('job_operations')
    .select(`
      *,
      operation_types!left(id, name, labor_rate)
    `)
    .eq('job_id', jobId)
    .order('sequence', { ascending: true });

  if (error) {
    console.error('Error fetching job operations:', error);
    throw error;
  }

  return (data || []) as JobOperation[];
}

/**
 * Create job operations from a routing
 */
export async function createJobOperationsFromRouting(
  jobId: string,
  routingId: string
): Promise<number> {
  const supabase = getSupabase();

  // Use the database function to create operations
  const { data, error } = await supabase.rpc('create_job_operations_from_routing', {
    p_job_id: jobId,
    p_routing_id: routingId,
  });

  if (error) {
    console.error('Error creating job operations from routing:', error);
    throw error;
  }

  return data as number;
}

/**
 * Update a job operation
 */
export async function updateJobOperation(
  operationId: string,
  updates: {
    status?: JobOperation['status'];
    actual_setup_hours?: number;
    actual_run_hours?: number;
    quantity_completed?: number;
    quantity_scrapped?: number;
    notes?: string;
  }
): Promise<JobOperation> {
  const supabase = getSupabase();

  // Get current user for completed_by
  const { data: { user } } = await supabase.auth.getUser();

  const updateData: Record<string, unknown> = {
    ...updates,
    updated_at: new Date().toISOString(),
  };

  // Set timestamps based on status changes
  if (updates.status === 'in_progress') {
    updateData.started_at = new Date().toISOString();
  } else if (updates.status === 'completed') {
    updateData.completed_at = new Date().toISOString();
    updateData.completed_by = user?.id || null;
  }

  const { data, error } = await supabase
    .from('job_operations')
    .update(updateData)
    .eq('id', operationId)
    .select(`
      *,
      operation_types!left(id, name, labor_rate)
    `)
    .single();

  if (error) {
    console.error('Error updating job operation:', error);
    throw error;
  }

  return data as JobOperation;
}

// ============== Attachments ==============

/**
 * Get attachments for a job
 */
export async function getJobAttachments(jobId: string): Promise<JobAttachment[]> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('job_attachments')
    .select('*')
    .eq('job_id', jobId)
    .order('uploaded_at', { ascending: false });

  if (error) {
    console.error('Error fetching job attachments:', error);
    throw error;
  }

  return data || [];
}

/**
 * Get signed URL for job attachment download
 */
export async function getJobAttachmentUrl(filePath: string): Promise<string> {
  return getSignedUrl(filePath, 3600);
}

// ============== Helper Functions ==============

/**
 * Get customers for dropdown (simple list)
 */
export async function getCustomersForSelect(
  companyId: string
): Promise<Array<{ id: string; name: string; customer_code: string | null }>> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('customers')
    .select('id, name, customer_code')
    .eq('company_id', companyId)
    .order('name');

  if (error) {
    console.error('Error fetching customers for select:', error);
    throw error;
  }

  return data || [];
}

/**
 * Get parts for a customer (for dropdown)
 */
export async function getPartsForCustomer(
  companyId: string,
  customerId: string
): Promise<Array<{ id: string; part_number: string; description: string | null }>> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('parts')
    .select('id, part_number, description')
    .eq('company_id', companyId)
    .eq('customer_id', customerId)
    .order('part_number');

  if (error) {
    console.error('Error fetching parts for customer:', error);
    throw error;
  }

  return data || [];
}

/**
 * Get routings for a part (for dropdown)
 */
export async function getRoutingsForPart(
  companyId: string,
  partId: string
): Promise<Array<{ id: string; name: string; is_default: boolean }>> {
  const supabase = getSupabase();

  const { data, error } = await supabase
    .from('routings')
    .select('id, name, is_default')
    .eq('company_id', companyId)
    .eq('part_id', partId)
    .order('is_default', { ascending: false })
    .order('name');

  if (error) {
    console.error('Error fetching routings for part:', error);
    throw error;
  }

  return data || [];
}
